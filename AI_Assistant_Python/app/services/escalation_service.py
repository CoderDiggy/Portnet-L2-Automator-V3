"""
Escalation Summary Service
Generates automated summaries for incident escalation to other teams
"""

import logging
from typing import List, Dict, Optional
from datetime import datetime, timedelta
from app.models.schemas import IncidentAnalysis, EscalationSummary, EscalationTemplate, Incident

logger = logging.getLogger(__name__)

class EscalationService:
    """Service for generating escalation summaries and communication templates"""
    
    def __init__(self):
        self.severity_keywords = {
            "Critical": ["critical", "outage", "down", "failure", "emergency", "urgent", "broken"],
            "High": ["error", "stuck", "timeout", "unable", "failed", "issue", "problem"],
            "Medium": ["slow", "delay", "warning", "concern", "inconsistent"],
            "Low": ["cosmetic", "minor", "suggestion", "enhancement"]
        }
        
        self.business_impact_templates = {
            "Container Management": "Container operations and cargo processing may be affected",
            "Vessel Operations": "Vessel arrivals, departures, and scheduling may be impacted",
            "EDI Processing": "Electronic data interchange and external system communication disrupted",
            "Terminal Operations": "Terminal gate operations and access control affected",
            "Financial Operations": "Billing and financial transaction processing impacted"
        }
        
        self.expertise_mapping = {
            "Container Management": ["Container Operations Team", "PORTNET® Support"],
            "Vessel Operations": ["Marine Operations", "Port Operations"],
            "EDI Processing": ["IT Integration Team", "EDI Specialists"],
            "Terminal Operations": ["Terminal Operations", "Gate Control"],
            "Financial Operations": ["Finance Team", "Billing Support"]
        }
    
    def generate_escalation_summary(self, 
                                  incident: Incident, 
                                  analysis: IncidentAnalysis, 
                                  solutions_count: int = 0) -> EscalationSummary:
        """Generate escalation summary based on incident analysis"""
        
        # Determine severity level
        severity = self._determine_severity(incident.description, analysis.urgency)
        
        # Generate business impact assessment
        business_impact = self._generate_business_impact(analysis.incident_type, analysis.affected_systems)
        
        # Create technical summary
        technical_summary = self._generate_technical_summary(incident, analysis)
        
        # Generate recommended actions
        recommended_actions = self._generate_recommended_actions(analysis, solutions_count)
        
        # Determine escalation reason
        escalation_reason = self._determine_escalation_reason(severity, analysis)
        
        # Estimate resolution time
        estimated_time = self._estimate_resolution_time(severity, analysis.incident_type)
        
        # Identify required expertise
        required_expertise = self._identify_required_expertise(analysis.incident_type, analysis.affected_systems)
        
        # Set contact priority
        contact_priority = self._determine_contact_priority(severity)
        
        return EscalationSummary(
            incident_id=incident.id,
            severity_level=severity,
            business_impact=business_impact,
            technical_summary=technical_summary,
            recommended_actions=recommended_actions,
            escalation_reason=escalation_reason,
            estimated_resolution_time=estimated_time,
            required_expertise=required_expertise,
            contact_priority=contact_priority
        )
    
    def generate_escalation_templates(self, 
                                    incident: Incident, 
                                    summary: EscalationSummary) -> EscalationTemplate:
        """Generate communication templates for different platforms"""
        
        # Email template
        email_subject = f"🚨 {summary.severity_level} Priority: {incident.title or 'System Incident'} - ID: {incident.id[:8]}"
        
        email_body = f"""
INCIDENT ESCALATION NOTIFICATION

📋 INCIDENT DETAILS:
• Incident ID: {incident.id}
• Severity: {summary.severity_level}
• Reported: {incident.reported_at.strftime('%Y-%m-%d %H:%M:%S UTC')}
• Source: {incident.source}

🎯 BUSINESS IMPACT:
{summary.business_impact}

🔧 TECHNICAL SUMMARY:
{summary.technical_summary}

⚡ RECOMMENDED ACTIONS:
{chr(10).join(f"• {action}" for action in summary.recommended_actions)}

🕐 ESTIMATED RESOLUTION TIME:
{summary.estimated_resolution_time}

👥 REQUIRED EXPERTISE:
{', '.join(summary.required_expertise)}

📞 CONTACT PRIORITY: {summary.contact_priority}

---
This escalation was automatically generated by the AI Duty Officer Assistant.
For questions, contact the Operations Center.
        """.strip()
        
        # SMS template (short version)
        sms_message = f"🚨 {summary.severity_level}: {incident.title or 'Incident'} [{incident.id[:8]}] - {summary.business_impact[:100]}... ETA: {summary.estimated_resolution_time}. Contact ops center."
        
        # Slack template
        slack_message = f"""
🚨 *{summary.severity_level} Priority Incident Escalation*

*Incident:* {incident.title or 'System Incident'} (`{incident.id[:8]}`)
*Impact:* {summary.business_impact}
*ETA:* {summary.estimated_resolution_time}
*Teams Needed:* {', '.join(summary.required_expertise)}

*Technical Details:*
```{summary.technical_summary}```

*Actions Required:*
{chr(10).join(f"• {action}" for action in summary.recommended_actions)}
        """.strip()
        
        # Microsoft Teams template
        teams_message = f"""
**🚨 Incident Escalation - {summary.severity_level} Priority**

| Field | Value |
|-------|-------|
| **Incident ID** | {incident.id} |
| **Severity** | {summary.severity_level} |
| **Business Impact** | {summary.business_impact} |
| **Estimated Resolution** | {summary.estimated_resolution_time} |
| **Required Teams** | {', '.join(summary.required_expertise)} |

**Technical Summary:**
{summary.technical_summary}

**Recommended Actions:**
{chr(10).join(f"- {action}" for action in summary.recommended_actions)}
        """.strip()
        
        return EscalationTemplate(
            email_subject=email_subject,
            email_body=email_body,
            sms_message=sms_message,
            slack_message=slack_message,
            teams_message=teams_message
        )
    
    def _determine_severity(self, description: str, urgency: str) -> str:
        """Determine severity level based on description and analysis"""
        description_lower = description.lower()
        
        # Check for critical keywords
        for severity, keywords in self.severity_keywords.items():
            if any(keyword in description_lower for keyword in keywords):
                return severity
        
        # Fallback to analysis urgency
        urgency_mapping = {
            "High": "High",
            "Medium": "Medium", 
            "Low": "Low"
        }
        return urgency_mapping.get(urgency, "Medium")
    
    def _generate_business_impact(self, incident_type: str, affected_systems: List[str]) -> str:
        """Generate business impact assessment"""
        base_impact = self.business_impact_templates.get(incident_type, "System operations may be affected")
        
        if affected_systems:
            systems_text = ", ".join(affected_systems)
            return f"{base_impact}. Affected systems: {systems_text}."
        
        return base_impact + "."
    
    def _generate_technical_summary(self, incident: Incident, analysis: IncidentAnalysis) -> str:
        """Generate technical summary for escalation"""
        summary_parts = []
        
        if analysis.incident_type:
            summary_parts.append(f"Type: {analysis.incident_type}")
        
        if analysis.pattern_match:
            summary_parts.append(f"Pattern: {analysis.pattern_match}")
        
        if analysis.root_cause:
            # Truncate root cause if too long
            root_cause = analysis.root_cause[:200] + "..." if len(analysis.root_cause) > 200 else analysis.root_cause
            summary_parts.append(f"Root Cause: {root_cause}")
        
        summary_parts.append(f"Description: {incident.description[:150]}{'...' if len(incident.description) > 150 else ''}")
        
        return " | ".join(summary_parts)
    
    def _generate_recommended_actions(self, analysis: IncidentAnalysis, solutions_count: int) -> List[str]:
        """Generate recommended actions based on analysis"""
        actions = []
        
        if solutions_count > 0:
            actions.append(f"Review {solutions_count} similar solutions in knowledge base")
        
        if analysis.affected_systems:
            actions.append(f"Check system status for: {', '.join(analysis.affected_systems)}")
        
        if "container" in analysis.incident_type.lower():
            actions.append("Verify container data integrity and EDI message status")
        elif "vessel" in analysis.incident_type.lower():
            actions.append("Check vessel schedule and berth allocation")
        elif "edi" in analysis.incident_type.lower():
            actions.append("Review EDI message logs and external system connectivity")
        
        actions.append("Escalate to appropriate technical team for resolution")
        
        return actions
    
    def _determine_escalation_reason(self, severity: str, analysis: IncidentAnalysis) -> str:
        """Determine why escalation is needed"""
        if severity == "Critical":
            return "Critical system impact requiring immediate attention"
        elif severity == "High":
            return "High priority issue affecting operations"
        elif len(analysis.affected_systems) > 1:
            return "Multi-system impact requiring coordination"
        else:
            return "Technical expertise required for resolution"
    
    def _estimate_resolution_time(self, severity: str, incident_type: str) -> str:
        """Estimate resolution time based on severity and type"""
        time_estimates = {
            "Critical": "1-2 hours",
            "High": "2-4 hours", 
            "Medium": "4-8 hours",
            "Low": "1-2 business days"
        }
        
        base_time = time_estimates.get(severity, "4-8 hours")
        
        # Adjust for complex incident types
        if any(keyword in incident_type.lower() for keyword in ["edi", "integration", "multi"]):
            return f"{base_time} (may extend due to integration complexity)"
        
        return base_time
    
    def _identify_required_expertise(self, incident_type: str, affected_systems: List[str]) -> List[str]:
        """Identify required expertise based on incident type"""
        expertise = set()
        
        # Add expertise based on incident type
        expertise.update(self.expertise_mapping.get(incident_type, ["Technical Support"]))
        
        # Add expertise based on affected systems
        for system in affected_systems:
            if "PORTNET" in system:
                expertise.add("PORTNET® Support")
            elif "EDI" in system:
                expertise.add("EDI Specialists")
            elif "Database" in system:
                expertise.add("Database Administrators")
        
        return list(expertise)
    
    def _determine_contact_priority(self, severity: str) -> str:
        """Determine contact priority level"""
        priority_mapping = {
            "Critical": "Emergency",
            "High": "Urgent",
            "Medium": "Normal",
            "Low": "Normal"
        }
        return priority_mapping.get(severity, "Normal")